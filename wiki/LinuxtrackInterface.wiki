#summary Description of linuxtrack interface.
#labels Phase-Implementation

= Introduction =

This page describes linuxtrack inteface, that allows building in headtracking capability to any program.

= Details =

Linuxtrack interface is pretty simple:

{{{
typedef enum {
  INITIALIZING,
  RUNNING,
  PAUSED,
  STOPPED,
  ERROR
}ltr_state_type;

int ltr_init(char *cust_section);
int ltr_shutdown(void);
int ltr_suspend(void);
int ltr_wakeup(void);
void ltr_recenter(void);
int ltr_get_camera_update(float *heading,
                         float *pitch,
                         float *roll,
                         float *tx,
                         float *ty,
                         float *tz,
                         uint32_t *counter);
ltr_state_type ltr_get_tracking_state(void);
void ltr_log_message(const char *format, ...);
}}}

Lets describe its functions in a more detailed way:

{{{
int ltr_init(char *cust_section);
}}}
This function initializes headtracking.

Parameter _cust_section_ is a pointer to a string containing name of the profile to be used by the application.
 
This way user can customize the headtracking for each application separately.

If NULL is specified, default profile is used.

It is recomended to use unique string (like name of your application) to prevent clashes.

Returns zero on success, nonzero value otherwise.
----
{{{
int ltr_shutdown(void);
int ltr_suspend(void);
int ltr_wakeup(void);
void ltr_recenter(void);
}}}

These functions allow you to shutdown, suspend (temporarily stop), wakeup (from suspend) and recenter the tracker.

They are non-blocking, which means that the request will not be fulfilled upon return, but it will be carried out as soon as possible.

To check the current state, please use *ltr_get_tracking_state* function.
----
{{{
int ltr_get_camera_update(float *heading,
                         float *pitch,
                         float *roll,
                         float *tx,
                         float *ty,
                         float *tz,
                         uint32_t *counter);
}}}

This is the main function of the linuxtrack interface. It is meant to be called once per frame to update the view.

Its parameters are pointers to floats, that will contain corresponding rotations (in degrees) and translations (in milimeters) upon successfull return.

The counter parameter is pointer to the 32-bit integer, that receives current camera frame number.

Returns zero on success, nonzero value otherwise.
----
{{{
typedef enum {
  INITIALIZING,
  RUNNING,
  PAUSED,
  STOPPED,
  ERROR
}ltr_state_type;

ltr_state_type ltr_get_tracking_state(void);
}}}

This function returns current linuxtrack state:
 * INITIALIZING means tracker is being initialized
 * RUNNING means tracking is on
 * PAUSED means tracking is suspended
 * STOPPED means tracker is shut down 
 * DOWN means that tracking was not initialized yet

----
{{{
void ltr_log_message(const char *format, ...);
}}}

This is utility function, allowing you to log messages to the linuxtrack logfile. Its usage is similar to the printf function.

 = Linuxtrack Hello World =
Here is the small "hello world" type of program showing usage of linuxtrack interface.

{{{
#include <linuxtrack.h>
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
  (void) argc;
  (void) argv;
  printf("Hello World!\n");
  //Initialize the tracking using Default profile
  ltr_init(NULL);
  //Wait for tracker initialization
  ltr_state_type state;
  int timeout = 100; //10 seconds timeout (for example firmware load...)
  while(timeout > 0){
    state = ltr_get_tracking_state();
    if(state != RUNNING){
      usleep(100000); //sleep 0.1s
    }else{
      break;
    }
    --timeout;
  };
  
  if(ltr_get_tracking_state() != RUNNING){
    printf("Initialization is taking too long!\n");
    return 1;
  }
  
  int i;
  float heading, pitch, roll, x, y, z;
  unsigned int counter;
  
  ltr_recenter();  
  
  for(i = 0; i < 30; ++i){
    ltr_get_camera_update(&heading, &pitch, &roll, &x, &y, &z, &counter);
    printf("%f  %f  %f\n  %f  %f  %f\n", heading, pitch, roll, x, y, z);
    usleep(100000);
  }
  
  ltr_suspend();
  sleep(2);
  ltr_wakeup();
  
  for(i = 0; i < 30; ++i){
    ltr_get_camera_update(&heading, &pitch, &roll, &x, &y, &z, &counter);
    printf("%f  %f  %f\n  %f  %f  %f\n", heading, pitch, roll, x, y, z);
    usleep(100000);
  }

  ltr_shutdown();
  return 0;
}
}}}

 == Compilation on Linux ==
To compile this program on Linux, use the following commands (just make the LTR_PREFIX point where you have linuxtrack installed):

{{{
export LTR_PREFIX=/opt/linuxtrack
gcc -o ltr_hw -Wall -g -I ${LTR_PREFIX}/include ltr_hw.c ${LTR_PREFIX}/lib/liblinuxtrack.a 
}}}

 == Compilation on MacOS X using XCode ==
Create an XCode project (for this example Command Line utility, Standard tool),
and add the linuxtrack.h to the sources (can be drag'n'dropped).

Then add the liblinuxtrack.a library to libraries (Ctrl-click on "Link Binary with Libraries", Add, Existing files...).

The result should look similar to this:

[http://linux-track.googlecode.com/files/xcode_main.png]

Then adjust in Project Info the target SDK...

[http://linux-track.googlecode.com/files/xcode_prj_gen.png]

and deployment target

[http://linux-track.googlecode.com/files/xcode_prj_bu.png]

Now you can build the project and before running it, open the console window
(menu Run / Console) to see the results.


 == Compilation on MacOS X 10.5 commandline ==
To compile this program on MacOS X, use the following commands (just make the LTR_PREFIX point where you have linuxtrack installed):

{{{
export LTR_PREFIX=~/Desktop/develop/
export MACOSX_DEPLOYMENT_TARGET=10.4
gcc -o ltr_hw -arch i386 -arch ppc -isysroot /Developer/SDKs/MacOSX10.4u.sdk \
  -mmacosx-version-min=10.4 -I${LTR_PREFIX} ltr_hw.c ${LTR_PREFIX}/liblinuxtrack.a
}}}

This will compile universal binary, that should be compatible with 10.4 - 10.6 both Intel and PPC.

 == Compilation on MacOS X 10.6 ==
To compile this code on MacOS X 10.6, you have to use GCC4.0, otherwise you get lots of errors (other way would be to compile using 10.5 SDK, but then you lose 10.4 compatibility).

For the commandline, instead of 'gcc' use 'gcc-4.0' (cpp-4.0, g++-4.0).

In XCode, in the "Project Info" window, Build pane select "C/C++ Compiler version" to GCC 4.0. 


 == Creating dynamic library ==
The static library liblinuxtrack.a is suitable only for programs. Should you need to create a dynamic library (plugin, ...) that would contain tracking functionality, instead of the static library just add linuxtrack.c file to your sources; it will allow you to compile it in a way you need (e.g. using -fpic...).