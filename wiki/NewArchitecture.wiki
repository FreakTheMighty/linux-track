#summary Summary of architectural changes in linuxtrack
= Introduction =

Time passed and it turned out, that the first concept of static library is not going to work well... 
I'm going to do some changes to the whole concept and this page should summarize those changes and reasons behind that lead to this.

*Feel free to comment - I'd like to hear your ideas!*

= Details =

== The linuxtrack concept ==
At first I thought that static library will be ideal format - it is easy to incorporate into application, no problems with dynamic libraries and so on.

Soon several problems popped up - especially it is impossible to hide internal functions, which pollutes namespace... Also it is impossible to compile an app and distribute it, since user would have to install all dependences, or the whole thing would have to be compiled statically, which is not the best idea...

So the first change will be following: the application will link against a small library, that will communicate with the tracker itself. The channel will allow the tracker to run on different machine, but it is more a side effect, than a target.

The tracker will be a standalone "server" application - there are several reasons to go this way... It is possible to make the main application independent of the tracker itself - no more crashes of application caused by bug in linuxtrack. Also there are several advantages for Mac development - some interfaces expect the main thread is running message loop, which is hard to guarantee with static lib, but implementable in a standalone app.

Server would be responsible for determining absolute rotations/translations and sending those informations to the client part.

The client would determine rotations/translations relative to the center point, filtration and other post-processing (dead-zones, sensitivity curves...).

All "drivers" will be compiled as independent dynamic libraries, loaded on the fly by tracker - it will allow for easy distribution of compiled linuxtrack; so no more people scared by word "compile" ;-)

For the gui - I'm not sure how exactly to abstract linuxtrack from the gui system used...
I'm going to use Qt for that, but I'd like to allow other gui systems to be used.
I've chosen Qt, because I'm much more familiar with it, than for example Gtk, PyGtk, Tcl/Tk...

I'd like to detach the tracker itself from the setup part - gui would just communicate with it through a special interface. Pref interface from linuxtrack will change into some abstract interface for controls - slider, string, number, menu...
Those controls should be able to load/save their current state, notify through callbacks on change...
